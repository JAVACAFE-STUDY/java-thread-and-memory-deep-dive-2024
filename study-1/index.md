#### 01
T: 동시에 여러 프로그램을 실행 할 수 있는 운영체제의 장점  

자원 활용  
- 하나의 프로그램이 기다리는 동안 다른 프로그래밍을 실행하여 효율적    

공정성  
- 여러 사용자, 프로그래밍이 컴퓨터 자원에 대해 동일 권한을 가져 더 작은 단위로 공유  

편의성  
- 여러 작업을 전부 처리하는 하나의 프로그램보다 각기 일을 하는 프로그램들을 작성하면 쉽다

T: 스레드의 장점  
- 멀티 프로세서 활용 가능하다  
- 스레드마다 한 종류의 일을 처리하여 단순하고 특정 동기화 시점에서만 상호작용이 발생한다  
- 단순한 비동기 이벤트 처리
  - 단일 스레드에서 여러 요청에 대한 처리를 하는 경우 연산을 위한 대기가 발행하고 작업이 멈춘다
  - 운영체제에서 많은 스레드를 제공하면 non-blocking 방법을 사용해야 하는 이유가 줄어든다
  - non-blocking 방법은 별개의 스레드로 작업하는 것 보다 상대적으로 복잡하고 실수하기 쉬운 상황이 발생할 수 있다
  
T: 스레드 사용의 위험성  
- 데이터가 일관성을 유지하기 어렵다(e.g., race condition)  
- 활동성 장애발생 가능(어떤 작업이 전혀 진전되지 못하는 상태)
  - 활동성: 원하는 일이 결국 일어난다  
- 성능 위험(컨텍스트 스위칭, 부하)  

** thread == light-weight process
#### 02
T: 스레드 안정성  
- 스레드 안전한 클래스 설계는 객체 지향 기법이 도움이 된다  
- 캡슐화 및 불변 객체를 잘 활용해야 한다
- 상태가 없는 객체는 스레드 안전하다(스레드간 처리 결과에 서로 영향이 없다)

T: 단일 연산  
- 경쟁조건, 늦은 초기화에서 경쟁조건에서 타이밍이 안 좋을 때 문제가 발생
- 스레드 안전성을 보장하기 위하여 점검 후 행동과 읽고 쓰기와 같은 일련의 동작, 즉 복합 동작으로 실행할 수 있다

T: 락
- 동기화 수단으로 락을 사용할 수 있다  
  - 암묵적인 락: synchronized 블록으로 락을 소유해서 단일 연산으로 실행 가능하다
    - 재진입이 가능하여 한번에 한 스레드만 특정 락을 소유한다
    - 스레드 단위로 락을 얻는 것을 의미한다
    - 재진입성 때문에 락의 동작을 캡슐화가 가능하고 데드락을 피할 수 있게 도와준다
- 락으로 상태를 보호하는 것은 모든 데이터에 해당하지 않으며 변경 가능한 데이터를 여러 스레드에서  
  접근해 사용하는 경우에 해당한다
- 복잡하고 오래 걸리는 작업에는 가능하다면 락을 잡지 않는 것이 좋다

#### 03
객체 공유    
가시성: 동기화 되지 않은 상황에서 메모리상의 변수를 대상으로 작성해둔 코드가  
항상 의도한 순서로 동작한다고 보장은 할 수 없다
 
stale data  
- 동기화 되지 않은 프로그램을 실행했을 때 나타날 수 있는 데이터(outdated data)
- 전혀 난데 없는 값이 생기는 경우는 64비트 사용하는 숫자형이나 volatile 미사용에서 찾아 볼 수 있다

락과 가시성  
여러 스레드가 공유해 사용하는 변수를 각 스레드에서 각자 최신값으로 활용하려면 락을 사용해 동기화 필요

volatile 변수에서 값은 항상 최신 값을 얻는다  
다음의 상황에서 사용하는 것이 좋다  
- 변수에 값을 저장하는 작업이 해당 변수의 현재 값과 관련이 없거나 해당 변수의 값을 변경하는 스레드가 하나만 존재    
- 해당 변수가 객체의 불변조건을 이루는 다른 변수와 달리 불변조건에 관련되어 있지 않다
- 해당 변수를 사용하는 동안 어떤 경우라도 락을 걸어 둘 필요가 없는 경우

공개와 유출  
객체가 안정적이지 않은 상태에서 공개하면 스레드 안정석에 문제가 발생 할 수 있다  
유출 상태: 의도하지 않았으나 공개 된 경우  
생성 메소드 안정성: 생성 메소드에서 this 변수가 외부로 유출되지 않는 편이 좋다

스레드 한정  
객체를 사용하는 스레드를 한정하는 방법으로 스레드 안정성 확보가능
- jdbc 커넥션 풀: 공유하는 객체를 풀로 관리하면 특정 연결을 한번에 하나 이상의 스레드가 사용 못하도록 가능

스택 한정  
특정 객체를 로컬 변수를 통해서만 사용가능 하도록 하는 경우(ThreadLocal 클래스 의미 아님)
  - 로컬 변수는 실행 중인 스레드에 한정 되어 있다고 볼 수 있다.
  - 스택 한정 상태 유지를 위하여 객체 참조가 외부로 유출되지 않도록 해야함

불변성  
불변 객체는 스레드에 안전하다  
불변객체는 다음을 만족한다
  - 생성 후 객체 상태 변경 불가
  - 내부 모든 변수는 final(필수는 아님)
  - this 대한 참조가 외뷰 유출 되지 않도록 주의

정리:
 - 스레드한정: 해당 스레드 내부에 존재하고 그 스레드에서만 호출
 - 읽기 전용 개체공유: 동기화 작업 없이 스레드에 안전하다
 - 스레드에 안전한 객체를 공유
 - 동기화 방법 적용
